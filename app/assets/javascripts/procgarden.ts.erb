// -*- mode: typescript -*-
/// <reference path="./typings/angularjs/angular.d.ts"/>
/// <reference path="./typings/codemirror/codemirror.d.ts"/>
/// <reference path="./base64_utf8.ts"/>

module ProcGarden {
    interface Gon {
        profiles: Array<Profile>
    }
    declare var gon: Gon;

    interface ExecProfile {
        extention: string;
        raw_commands: Array<string>;
        raw_envs: {[key: string]: string};
        fixed_commands: Array<Array<string>>;
        selectable_options: {[key: string]: Array<string>};
        cpu_limit: number;
        memory_limit: number
    }

    interface Profile {
        name: string;
        version: string;
        display_version: string;
        is_build_required: boolean;
        is_link_independent: boolean;
        compile: ExecProfile;
        link: ExecProfile;
        exec: ExecProfile;
    }

    class SourceCode {
        constructor(public filename: string, public code: string) {
        }
    }


    class ExecInstruction {
        constructor() {
        }

        public update(resp: Response.ExecStatus) {
            if ( resp == null ) return;

            console.log("response", resp);

            this.exited = resp.exited;
            this.exitStatus = resp.exit_status;
            this.signaled = resp.signaled;
            this.signal = resp.signal;
            this.usedCpuTimeSec = resp.used_cpu_time_sec;
            this.usedMemoryBytes = resp.used_memory_bytes;
            this.systemErrorStatus = resp.system_error_status;
            this.systemErrorMessage = resp.system_error_message;

            this.nextOutputOffset = resp.outputs_next_offset;
            resp.outputs.forEach((out: Response.Output) => {
                var decodedBuffer = Util.b64ToUtf8(out.buffer);
                switch(out.fd) {
                case Response.OutputType.stdout:
                    this.stdout += decodedBuffer;
                    break;
                case Response.OutputType.stderr:
                    this.stderr += decodedBuffer;
                    break
                }
            });
        }

        public reset() {
            this.exited = null;
            this.exitStatus = null;
            this.signaled = null;
            this.signal = null;
            this.usedCpuTimeSec = null;
            this.usedMemoryBytes = null;
            this.systemErrorStatus = null;
            this.systemErrorMessage = null;

            this.nextOutputOffset = 0;
            this.stdout = "";
            this.stderr = "";
        }

        public toRequest() {
            return {
                stdin: this.stdin,
                commands: this.commands,
                options: this.selectedOptions,
            }
        }

        // user input
        public stdin: string;
        public commands: Array<string>;
        public selectedOptions: Array<string>;

        // other
        public options: Array<string>;
        public nextOutputOffset: number = 0;

        public stdout: string;
        public stderr: string;
        public exited: boolean;
        public exitStatus: number;
        public signaled: boolean;
        public signal: number;
        public usedCpuTimeSec: number;
        public usedMemoryBytes: number;
        public systemErrorStatus: number;
        public systemErrorMessage: string;
    }

    class Ticket {
        constructor() {
            this.use = "dlang.dmd";
            this.version = "HEAD";
            this.do_exec = 1;

            this.compile = new ExecInstruction();
            this.link = new ExecInstruction();
            this.execs = [new ExecInstruction()];

            this.isFinished = false;
        }

        public update(resp: Response.Ticket) {
            this.phase = resp.phase;
            this.isFinished = resp.is_finished;

            if ( this.compile != null ) {
                this.compile.update(resp.compile);
            }
            if ( this.link != null ) {
                this.link.update(resp.link);
            }
            if ( this.execs != null ) {
                this.execs.forEach((e, index) => {
                    e.update(resp.execs[index]);
                });
            }
        }

        public reset() {
            this.phase = Response.Phase.waiting;
            this.isFinished = false;

            if ( this.compile != null ) {
                this.compile.reset();
            }
            if ( this.link != null ) {
                this.link.reset();
            }
            if ( this.execs != null ) {
                this.execs.forEach((e, index) => {
                    e.reset();
                });
            }
        }

        public offsetValues() {
            var value: any = {};
            if ( this.compile != null ) {
                value['compile'] = this.compile.nextOutputOffset;
            }
            if ( this.link != null ) {
                value['link'] = this.link.nextOutputOffset;
            }
            if ( this.execs != null ) {
                value['execs'] = this.execs.map((e) => e.nextOutputOffset);
            }

            return value;
        }

        public toRequest() {
            return {
                use: this.use,
                version: this.version,
                do_exec: this.do_exec,
                compile: this.compile.toRequest(),
                link: this.link.toRequest(),
                execs: this.execs.map((e) => e.toRequest()),
            }
        }

        // user
        public use: string;
        public version: string;
        public do_exec: number;

        public compile: ExecInstruction;
        public link: ExecInstruction;
        public execs: Array<ExecInstruction>;

        // from server
        public phase: Response.Phase;
        public isFinished: boolean;
    }

    module Response {
        export enum Phase {
            waiting = 0,
            notExecuted = 10,
            compiling = 200,
            compiled = 250,
            linking = 280,
            linked = 281,
            running = 300,
            success = 400,
            error = 401,
        }

        export enum OutputType {
            stdout = 1,
            stderr = 2,
        }

        export interface Output {
            buffer: string;
            fd: number;
        }

        export interface ExecStatus {
            index: number;
            exited: boolean;
            exit_status: number;
            signaled: boolean;
            signal: number;
            used_cpu_time_sec: number;
            used_memory_bytes: number;
            system_error_status: number;
            system_error_message: string;

            outputs_offset: number;
            outputs_next_offset: number;
            outputs: Array<Output>;

            created_at: string;
            updated_at: string;
        }

        export interface Ticket {
            index: number;
            do_execute: number;
            proc_name: string;
            proc_version: string;
            proc_label: string;
            phase: number;
            is_finished: boolean;

            compile: ExecStatus;
            link: ExecStatus;
            execs: Array<ExecStatus>;

            entry_id: number;
            created_at: string;
            updated_at: string;
        }
    }



    module TicketExecDirective {
        export class Controller {
            constructor() {
                console.log("exec", this);
            }

            public getFormattedCPUTime(): string {
                if ( this.exec.usedCpuTimeSec == null ) {
                    return "";
                }
                var lim = ( this.execProfile.cpu_limit != null ) ?
                    `/${this.execProfile.cpu_limit}` : '';
                return `${this.exec.usedCpuTimeSec.toFixed(4)}${lim}`;
            }

            public getFormattedMemoryUsage(): string {
                if ( this.exec.usedMemoryBytes == null ) {
                    return "";
                }
                var lim = ( this.execProfile.memory_limit != null ) ?
                    `/${this.execProfile.memory_limit/1024}` : '';

                return `${this.exec.usedMemoryBytes/1024}${lim}`;
            }

            public name: string;
            public exec: ExecInstruction;
            public execProfile: ExecProfile;

            public isAccordionOpen: boolean = true;
        }

        export class Directive implements ng.IDirective {
            restrict = 'AE';
            transclude = true;
            replace = false;
            scope = true;
            bindToController = {
                name: '@',
                exec: '=',
                execProfile: '=',
                isAccordionOpen: '=',
            };
            controller = [Controller];
            controllerAs = 'ctrl';

            templateUrl = '<%= asset_path("templates/_ticket_exec.html") %>';
        }
    }

    module TicketExecInputDirective {
        export class Controller extends TicketExecDirective.Controller {
        }

        export class Directive implements ng.IDirective {
            restrict = 'AE';
            transclude = true;
            replace = false;
            scope = true;
            bindToController = {
                name: '@',
                exec: '=',
                execProfile: '=',
            };
            controller = [Controller];
            controllerAs = 'ctrl';

            templateUrl = '<%= asset_path("templates/_ticket_exec_input.html") %>';
        }
    }

    module TicketDirective {
        export class Controller {
            constructor() {
                this.profiles = gon.profiles;
                console.log(this.profiles);
                this.selectProfile(0);
            }

            public selectProfile(index: number) {
                this.currentProfile = this.profiles[index];
                console.log(this.currentProfile);
            }

            public getPhaseText(): string {
                switch(this.ticket.phase) {
                case Response.Phase.waiting:
                    return "Waiting...";
                case Response.Phase.notExecuted:
                    return "NotExecuted";
                case Response.Phase.compiling:
                    return "Compiling";
                case Response.Phase.compiled:
                    return "Compiled";
                case Response.Phase.linking:
                    return "Linking";
                case Response.Phase.linked:
                    return "Linked";
                case Response.Phase.running:
                    return "Running";
                case Response.Phase.success:
                    return "Finished";
                case Response.Phase.error:
                    return "SystemError";
                }

                return "";
            }

            public getPhaseStyle(): string {
                switch(this.ticket.phase) {
                case Response.Phase.waiting:
                    return "label-info";
                case Response.Phase.notExecuted:
                    return "label-default"
                case Response.Phase.compiling:
                    return "label-warning";
                case Response.Phase.compiled:
                    return "label-success";
                case Response.Phase.linking:
                    return "label-warning";
                case Response.Phase.linked:
                    return "label-success";
                case Response.Phase.running:
                    return "label-primary";
                case Response.Phase.success:
                    return "label-success";
                case Response.Phase.error:
                    return "label-danger";
                }

                return "";
            }

            private ticket: Ticket;
            private profiles: Array<Profile>;
            private currentProfile: Profile;
        }

        export class Directive implements ng.IDirective {
            restrict = 'AE';
            transclude = true;
            replace = true;
            scope = true;
            //require = ['^procgardenEntry'];
            bindToController = {
                ticket: '=',
                profiles: '=',
                currentProfile: '=',
            };
            controller = [Controller];
            controllerAs = 'ctrl';

            templateUrl = '<%= asset_path("templates/_ticket.html") %>';
        }
    }


    module EditorDirective {
        export class Controller {
            constructor() {
            }

            private codemirrorLoaded(editor: CodeMirror.Editor) {
                //editor.setSize('100%', '100%');
            }

            private sourceCode: SourceCode;
            private options = {
                lineNumbers: true,
            };
        }

        export class Directive implements ng.IDirective {
            restrict = 'AE';
            transclude = true;
            replace = true;
            scope = true;
            bindToController = {
                sourceCode: '=',
            };
            controller = [Controller];
            controllerAs = 'ctrl';

            templateUrl = '<%= asset_path("templates/_editor.html") %>';
        }
    }


    export module EntryDirective {
        export class Controller {
            constructor(
                private $http: ng.IHttpService,
                private $timeout: ng.ITimeoutService
            ) {
                var txt = `import std.stdio;

void main() {
	for(int i=0; i<20; ++i ) {
    	"Hello World!".writeln;
    }
}`;

                this.sourceCodes = [new SourceCode('main.d', txt)];
                this.tickets = [new Ticket()];
            }

            public submit() {
                this.$http.post('/api/v1/entries', {
                    visibility: 1,
                    source_codes: this.sourceCodes,
                    tickets: this.tickets.map((t) => t.toRequest()),
                }).success((data: any, status: any, headers: any, config: any) => {
                    // TODO: error check1
                    console.log("success", data);

                    data.ticket_ids.forEach((id: number, index: number) => {
                        this.tickets[index].reset();
                        this.wait_for_ticket(id, this.tickets[index]);
                    });

                }).error((data: any, status: any, headers: any, config: any) => {
                    console.log("error", data);
                });

                console.log("submit!")
            }

            private wait_for_ticket(ticket_id: number, ticket: Ticket) {
                console.log("offset", ticket.offsetValues());
                this.$http.get(`/api/v1/tickets/${ticket_id}`, {
                    params: {
                        offsets: ticket.offsetValues(),
                    }
                }).success((data: Response.Ticket, status: any, headers: any, config: any) => {
                    console.log("ticket success", data);
                    // TODO: error check

                    ticket.update(data);

                    if ( data.is_finished == false ) {
                        this.$timeout(() => {
                            this.wait_for_ticket(ticket_id, ticket);
                        }, 200);
                    }

                }).error((data: any, status: any, headers: any, config: any) => {
                    console.log("ticket error", data);
                });
            }

            public sourceCodes: Array<SourceCode>;
            public tickets: Array<Ticket>;
        }

        export class Directive implements ng.IDirective {
            restrict = 'AE';
            transclude = true;
            replace = true;
            scope = true;
            bindToController = {
                sourceCodes: '=',
                tickets: '=',
            };
            controller = ['$http', '$timeout', Controller];
            controllerAs = 'ctrl';

            templateUrl = '<%= asset_path("templates/_entry.html") %>';
        }
    }

    var app = angular.module("procgarden", ['ui.bootstrap', 'ui.codemirror']);

    app
        .directive("procgardenEntry", () => new EntryDirective.Directive())
        .directive("procgardenEditor", () => new EditorDirective.Directive())
        .directive("procgardenTicket", () => new TicketDirective.Directive())
        .directive("procgardenTicketExec", () => new TicketExecDirective.Directive())
        .directive("procgardenTicketExecInput", () => new TicketExecInputDirective.Directive())

    console.log('loaded');
}
